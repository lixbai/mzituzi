"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const chalk_1 = __importDefault(require("chalk"));
const cli_progress_1 = __importDefault(require("cli-progress"));
const fancy_log_1 = __importDefault(require("fancy-log"));
const gulp_1 = require("gulp");
const map_1 = __importDefault(require("lodash/map"));
const uniq_1 = __importDefault(require("lodash/uniq"));
const process_1 = __importDefault(require("process"));
const time_stamp_1 = __importDefault(require("time-stamp"));
const task_extended_1 = __importDefault(require("../tasks/task-extended"));
const task_simple_1 = __importDefault(require("../tasks/task-simple"));
const config_1 = __importDefault(require("./config"));
const utils_1 = require("./utils");
/**
 * Factory that create all tasks.
 */
class TaskFactory {
    constructor() {
        /**
         * Global tasks grouped by step, name and type.
         * @type {GlobalTaskList}
         * @private
         */
        this._globalTasks = {};
        /**
         * List of used modules.
         * @type {ModuleClasses}
         * @private
         */
        this._modules = {};
        /**
         * Existing tasks grouped by steps of execution.
         * @type {string[][]}
         * @private
         */
        this._orderedGlobalTasks = [];
        /**
         * Ordered super global tasks group by step (lint, build, watch).
         * @type {{}}
         * @private
         */
        this._orderedSuperGlobalTasks = {};
        /**
         * List of super global tasks (lint, build, watch).
         * @type {TaskList}
         * @private
         */
        this._superGlobalTasks = {};
        /**
         * List of final tasks.
         * @type {string[]}
         * @private
         */
        this._tasks = [];
        /**
         * List of unique instance for simple modules.
         * @type {{}}
         * @private
         */
        this._uniqueInstances = {};
    }
    /**
     * Create all tasks.
     */
    createAllTasks() {
        const conf = config_1.default.getInstance();
        // Load all modules.
        this._loadModules(conf.settings);
        // Sort tasks to always have simple ones on top.
        const allTasks = Object.keys(conf.settings).sort((taskA, taskB) => {
            const isSimpleA = this._isTaskSimple(taskA);
            const isSimpleB = this._isTaskSimple(taskB);
            if (isSimpleA !== isSimpleB) {
                return isSimpleA && !isSimpleB ? -1 : 1;
            }
            return taskA < taskB ? -1 : taskA > taskB ? 1 : 0;
        });
        // Initialize all tasks.
        for (const task of allTasks) {
            this._createTasks(task, conf.settings[task]);
        }
        if (this._tasks.length > 0) {
            // Create global and super global tasks.
            this._createGlobalTasks();
            this._createSuperGlobalTasks();
            // Default task.
            gulp_1.task("default", gulp_1.series(this._orderedGlobalTasks.map((tasks) => tasks.length === 1 ? tasks[0] : gulp_1.parallel(tasks))));
        }
    }
    /**
     * Create a task.
     *
     * @param {string} task
     * @param {string} name
     * @param {TaskOptions} settings
     * @return {Task}
     */
    createTask(task, name, settings) {
        if (!TaskFactory._isValidTask(task)) {
            throw new Error(`Unsupported task: ${task}.`);
        }
        const module = this._loadModule(task);
        let instance;
        if (this._isTaskSimple(task)) {
            // eslint-disable-next-line @typescript-eslint/no-explicit-any
            instance = new module({
                settings,
            });
            if (!this._uniqueInstances[task]) {
                this._uniqueInstances[task] = instance;
            }
        }
        else {
            // eslint-disable-next-line @typescript-eslint/no-explicit-any
            instance = new module({
                name,
                settings,
                browsersync: this._getUniqueInstanceOf("browsersync"),
            });
        }
        return instance;
    }
    /**
     * Create global tasks grouped by step, name and type.
     *
     * @private
     */
    _createGlobalTasks() {
        // Group tasks by step, name and type.
        for (const task of this._tasks) {
            const { type, name, step } = utils_1.explodeTaskName(task);
            if (this._isTaskSimple(type)) {
                this._pushGlobalTask("byTypeOnly", type, task);
            }
            else {
                // Sort tasks by name.
                const sortedByName = `${type}:${name}`;
                this._pushGlobalTask("byName", sortedByName, task);
                // Sort tasks by step.
                const sortedByStep = `${type}:${step}`;
                this._pushGlobalTask("byStep", sortedByStep, task);
                // Sort tasks by type only.
                this._pushGlobalTask("byTypeOnly", type, sortedByName);
            }
        }
        // Create tasks sorted by type and name.
        if (this._globalTasks.byName) {
            for (const taskName of Object.keys(this._globalTasks.byName)) {
                this._globalTasks.byName[taskName].sort((itemA, itemB) => {
                    const { step: stepA } = utils_1.explodeTaskName(itemA);
                    const { step: stepB } = utils_1.explodeTaskName(itemB);
                    return utils_1.steps.indexOf(stepA) - utils_1.steps.indexOf(stepB);
                });
                this._defineTask(taskName, this._globalTasks.byName[taskName]);
            }
        }
        // Create tasks sorted by type and step.
        if (this._globalTasks.byStep) {
            for (const taskName of Object.keys(this._globalTasks.byStep)) {
                this._defineTask(taskName, this._globalTasks.byStep[taskName], this._runInParallel(taskName) ? "parallel" : "series");
            }
        }
        // Create tasks sorted by type only.
        if (this._globalTasks.byTypeOnly) {
            for (const taskName of Object.keys(this._globalTasks.byTypeOnly)) {
                this._defineTask(taskName, this._globalTasks.byTypeOnly[taskName], this._runInParallel(taskName) ? "parallel" : "series");
            }
            // Sort and order global tasks.
            this._orderedGlobalTasks = this._tasksGroupAndOrder()
                .map((taskNames) => taskNames.filter((taskName) => !!this._globalTasks.byTypeOnly[taskName]))
                .filter(TaskFactory._removeEmptyArrays);
        }
    }
    /**
     * Create super global tasks (lint, build, watch).
     *
     * @private
     */
    _createSuperGlobalTasks() {
        // Collect and group tasks.
        for (const task of this._tasks) {
            const { type, step } = utils_1.explodeTaskName(task);
            if (utils_1.steps.indexOf(step) >= 0) {
                TaskFactory._pushTask(this._superGlobalTasks, step, task);
            }
            else if (step === "start" && type === "clean") {
                TaskFactory._pushTask(this._superGlobalTasks, "build", task);
            }
            else if (step === "start") {
                TaskFactory._pushTask(this._superGlobalTasks, "watch", task);
            }
        }
        // Create super global tasks.
        for (const step of Object.keys(this._superGlobalTasks)) {
            // Sort and order super global tasks.
            this._orderedSuperGlobalTasks[step] = this._tasksGroupAndOrder()
                .map((taskNames) => {
                return taskNames
                    .map((type) => {
                    // Extract arrays of tasks of the type `type`.
                    const currentTasks = this._superGlobalTasks[step].filter((taskName) => {
                        const { type: currentType } = utils_1.explodeTaskName(taskName);
                        return type === currentType;
                    });
                    if (!this._isTaskSimple(type) && !this._runInParallel(type)) {
                        return [currentTasks];
                    }
                    return currentTasks;
                })
                    .reduce(
                // Merge all arrays.
                (acc, value) => [...acc, ...value], []);
            })
                .filter(TaskFactory._removeEmptyArrays);
            // Define super global task.
            if (this._orderedSuperGlobalTasks[step].length > 0) {
                this._defineTask(step, this._orderedSuperGlobalTasks[step].map((groups) => {
                    const tasks = groups.map((task) => {
                        if (typeof task === "string") {
                            return task;
                        }
                        return gulp_1.series(task);
                    });
                    return gulp_1.parallel(tasks);
                }));
            }
        }
    }
    /**
     * Create all tasks: lint, build and watch.
     *
     * @param {string} task
     * @param {ConfigOptions} tasks
     * @private
     */
    _createTasks(task, tasks) {
        const isSimple = this._isTaskSimple(task);
        const conf = config_1.default.getInstance();
        const { step: currentStep } = utils_1.explodeTaskName(conf.currentRun);
        if (isSimple && (currentStep === "" || currentStep === "watch")) {
            // Add simple tasks only for global or watch call.
            // eslint-disable-next-line @typescript-eslint/no-explicit-any
            const taskInstance = this.createTask(task, "", tasks);
            this._pushTask(taskInstance.taskStart());
            this._pushTask(taskInstance.taskWatch());
        }
        else if (!isSimple) {
            // Add classic tasks.
            for (const name of Object.keys(tasks)) {
                // eslint-disable-next-line @typescript-eslint/no-explicit-any
                const taskInstance = this.createTask(task, name, tasks[name]);
                // Add lint tasks only for global, lint or watch call.
                if (currentStep === "" || currentStep === "lint" || currentStep === "watch") {
                    this._pushTask(taskInstance.taskLint());
                }
                // Add lint tasks only for global, build or watch call.
                if (currentStep === "" || currentStep === "build" || currentStep === "watch") {
                    this._pushTask(taskInstance.taskBuild());
                }
                // Add lint tasks only for global or watch call.
                if (currentStep === "" || currentStep === "watch") {
                    this._pushTask(taskInstance.taskWatch());
                }
            }
        }
    }
    /**
     * Create gulp task.
     *
     * @param {string} taskName
     * @param {Undertaker.Task[]} tasks
     * @param {string} type
     * @private
     */
    _defineTask(taskName, tasks, type = "series") {
        const config = config_1.default.getInstance();
        const errorHandler = `${taskName}:error`;
        const addErrorHandler = (config.isLintRun() || config.isBuildRun()) && config.isCurrentRun(taskName);
        // Define gulp task to catch error in build run to exit with error code.
        if (addErrorHandler) {
            gulp_1.task(errorHandler, (done) => {
                done();
                if (task_extended_1.default.taskErrors.length > 0) {
                    process_1.default.exit(1);
                }
            });
        }
        let task = (done) => done();
        if (addErrorHandler) {
            // Add error handler to the tasks.
            let tasksWithHandler = [];
            if (type === "series") {
                tasksWithHandler = [...tasks, errorHandler];
            }
            else if (type === "parallel") {
                tasksWithHandler = [gulp_1.parallel(tasks), errorHandler];
            }
            if (tasksWithHandler.length) {
                task = gulp_1.series(tasksWithHandler);
            }
        }
        else if (type === "series") {
            task = gulp_1.series(tasks);
        }
        else if (type === "parallel") {
            task = gulp_1.parallel(tasks);
        }
        // Define gulp task.
        if (task.name === "series" || task.name === "parallel") {
            gulp_1.task(taskName, task);
        }
    }
    /**
     * Get unique instance of simple module.
     *
     * @param {string} name
     * @return {unknown | undefined}
     */
    _getUniqueInstanceOf(name) {
        return this._uniqueInstances[name];
    }
    /**
     * Check if a task is a simple one.
     *
     * @param {string} taskName
     * @return {boolean}
     * @private
     */
    _isTaskSimple(taskName) {
        const module = this._loadModule(taskName);
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        return module.prototype instanceof task_simple_1.default;
    }
    /**
     * Load module linked to task and keep it in cache.
     *
     * @param {string} taskName
     * @returns {unknown}
     * @private
     */
    _loadModule(taskName) {
        if (!this._modules[taskName]) {
            const module = TaskFactory._requireModule(taskName);
            if (!module) {
                return;
            }
            this._modules[taskName] = module;
        }
        return this._modules[taskName];
    }
    /**
     * Load all modules needed by current settings.
     *
     * @param {Options} settings
     * @returns {ModuleClasses}
     * @private
     */
    _loadModules(settings) {
        const tasks = Object.keys(settings);
        const progress = new cli_progress_1.default.Bar({
            format: "{time} [{bar}] | {percentage}% | {value}/{total} | {task}",
        });
        fancy_log_1.default("Loading modules...");
        progress.start(tasks.length, 0, {
            task: tasks[0],
            time: TaskFactory._logTime(),
        });
        for (const [index, task] of tasks.entries()) {
            progress.update(index, {
                task: index + 1 >= tasks.length ? " " : tasks[index + 1],
                time: TaskFactory._logTime(),
            });
            this._loadModule(task);
            progress.increment(1);
        }
        progress.stop();
        fancy_log_1.default("Modules loaded");
        return this._modules;
    }
    /**
     * Add task to list of global tasks.
     *
     * @param {string} sort
     * @param {string} key
     * @param {string} task
     * @return {GlobalTaskList}
     * @private
     */
    _pushGlobalTask(sort, key, task) {
        this._globalTasks[sort] = this._globalTasks[sort] || {};
        TaskFactory._pushTask(this._globalTasks[sort], key, task);
        return this._globalTasks;
    }
    /**
     * Add task to the list.
     *
     * @param {string} name
     * @return {string[]}
     * @private
     */
    _pushTask(name) {
        if (name !== "") {
            this._tasks.push(name);
        }
        return this._tasks;
    }
    /**
     * Check if a task run in parallel or series.
     *
     * @param {string} taskName
     * @returns {boolean}
     * @private
     */
    _runInParallel(taskName) {
        const { type } = utils_1.explodeTaskName(taskName);
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        const module = this._loadModule(type);
        return module.runInParallel;
    }
    /**
     * Tasks grouped by steps of execution.
     *
     * @return {string[][]}
     * @private
     */
    _tasksGroupAndOrder() {
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        const orders = map_1.default(this._modules, (module) => module.taskOrder);
        return uniq_1.default(orders.sort()).map((order) => Object.keys(this._modules).filter(
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        (task) => this._modules[task].taskOrder === order));
    }
    /**
     * Check if a task is valid (exists in supported tasks).
     *
     * @param {string} taskName
     * @return {boolean}
     * @private
     */
    static _isValidTask(taskName) {
        return utils_1.modules.indexOf(taskName) >= 0;
    }
    /**
     * Display current timestamp like Gulp.
     *
     * @returns {string}
     * @private
     */
    static _logTime() {
        return "[" + chalk_1.default.gray(time_stamp_1.default("HH:mm:ss")) + "]";
    }
    /**
     * Add a task in a list.
     *
     * @param {TaskList} list
     * @param {string} key
     * @param {string} task
     * @return {TaskList}
     * @private
     */
    static _pushTask(list, key, task) {
        list[key] = list[key] || [];
        if (list[key].indexOf(task) < 0) {
            list[key].push(task);
        }
        return list;
    }
    /**
     * Check if an array is empty. Used in filters.
     *
     * @param {unknown[]} tasks
     * @return {boolean}
     * @private
     */
    static _removeEmptyArrays(tasks) {
        if (!Array.isArray(tasks)) {
            return true;
        }
        tasks = tasks.map((task) => Array.isArray(task) ? task.filter(TaskFactory._removeEmptyArrays) : task);
        return tasks.length > 0;
    }
    /**
     * Import a module linked to a task.
     * @param {string} taskName
     * @returns {unknown}
     * @private
     */
    static _requireModule(taskName) {
        if (!TaskFactory._isValidTask(taskName)) {
            return;
        }
        // eslint-disable-next-line @typescript-eslint/no-var-requires
        const { default: module } = require(`../tasks/${taskName}`);
        return module;
    }
}
exports.default = TaskFactory;
//# sourceMappingURL=task-factory.js.map