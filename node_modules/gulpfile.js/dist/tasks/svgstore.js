"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const gulp_cheerio_1 = __importDefault(require("gulp-cheerio"));
const gulp_rename_1 = __importDefault(require("gulp-rename"));
const gulp_svgmin_1 = __importDefault(require("gulp-svgmin"));
const gulp_svgstore_1 = __importDefault(require("gulp-svgstore"));
const merge_1 = __importDefault(require("lodash/merge"));
const path_1 = __importDefault(require("path"));
const task_extended_1 = __importDefault(require("./task-extended"));
/**
 * Combine SVG files into one.
 */
class SVGStore extends task_extended_1.default {
    /**
     * Task constructor.
     *
     * @param {TaskOptions} options
     */
    constructor(options) {
        super(options);
        const defaultSettings = {
            svgmin: {
                plugins: [
                    {
                        inlineStyles: {
                            onlyMatchedOnce: true,
                            removeMatchedSelectors: true,
                        },
                    },
                    {
                        removeDoctype: true,
                    },
                    {
                        removeComments: true,
                    },
                    {
                        removeMetadata: true,
                    },
                    {
                        removeTitle: true,
                    },
                    {
                        removeDesc: true,
                    },
                    {
                        removeViewBox: false,
                    },
                    {
                        removeDimensions: true,
                    },
                ],
            },
            svgstore: {
                inlineSvg: true,
            },
        };
        this._settings.settings = merge_1.default(defaultSettings, this._settings.settings);
    }
    /**
     * Method to add specific steps for the build.
     *
     * @param {NodeJS.ReadableStream} stream
     * @return {NodeJS.ReadableStream}
     * @protected
     */
    _hookBuildBefore(stream) {
        return stream
            .pipe(gulp_svgmin_1.default((file) => merge_1.default(this._settings.settings.svgmin, {
            plugins: [
                {
                    cleanupIDs: {
                        force: true,
                        minify: true,
                        prefix: path_1.default.basename(file.relative, path_1.default.extname(file.relative)) + "-",
                    },
                },
            ],
        })))
            .pipe(gulp_svgstore_1.default(this._settings.settings.svgstore))
            .pipe(gulp_cheerio_1.default({
            parserOptions: {
                xmlMode: true,
            },
            run: ($, file, done) => {
                // Append view and use tags to the SVG.
                let offsetY = 0;
                let maxWidth = 0;
                const views = $("<views />");
                const uses = $("<uses />");
                $("symbol")
                    .filter((index, symbol) => !!symbol.attribs.id && !!symbol.attribs.viewBox)
                    .each((index, symbol) => {
                    if (this._settings.settings.prefix) {
                        symbol.attribs.id = `${this._settings.settings.prefix}-${symbol.attribs.id}`;
                    }
                    const [originX, , width, height] = symbol.attribs.viewBox
                        .split(" ")
                        .map((i) => Number(i));
                    const name = `${symbol.attribs.id}-icon`;
                    views.append(`<view id="${name}" viewBox="${originX} ${offsetY} ${width} ${height}" />`);
                    uses.append(`<use
                   xlink:href="#${symbol.attribs.id}"
                   width="${width}"
                   height="${height}"
                   x="${originX}"
                   y="${offsetY}" />`);
                    offsetY += height;
                    maxWidth = Math.max(maxWidth, width);
                });
                $("svg")
                    .attr("xmlns:xlink", "http://www.w3.org/1999/xlink")
                    .attr("viewBox", `0 0 ${maxWidth} ${offsetY}`)
                    .append("", views[0].children)
                    .append("", uses[0].children);
                if (done)
                    done();
            },
        }))
            .pipe(gulp_rename_1.default({
            basename: path_1.default.basename(this._settings.filename, path_1.default.extname(this._settings.filename)),
            extname: ".svg",
        }));
    }
}
exports.default = SVGStore;
/**
 * Global task name.
 * @type {string}
 * @readonly
 */
SVGStore.taskName = "svgstore";
/**
 * Level to order task in execution pipeline.
 * @type {number}
 * @readonly
 */
SVGStore.taskOrder = 20;
//# sourceMappingURL=svgstore.js.map