"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result["default"] = mod;
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
const fs_1 = __importDefault(require("fs"));
const gulp_data_1 = __importDefault(require("gulp-data"));
const gulp_pug_1 = __importDefault(require("gulp-pug"));
const gulp_pug_linter_1 = __importDefault(require("gulp-pug-linter"));
const yaml = __importStar(require("js-yaml"));
const merge_1 = __importDefault(require("lodash/merge"));
const puglint_stylish_1 = __importDefault(require("puglint-stylish"));
const config_1 = __importDefault(require("../libs/config"));
const task_extended_1 = __importDefault(require("./task-extended"));
/**
 * Build PUG files into HTML.
 */
class Pug extends task_extended_1.default {
    /**
     * Task constructor.
     *
     * @param {TaskOptions} options
     */
    constructor(options) {
        super(options);
        // Add data files to files to watch.
        if (typeof this._settings.settings.data === "string") {
            this._watchingFiles = [this._settings.settings.data];
        }
        else if (typeof this._settings.settings.data === "object") {
            this._watchingFiles = this._settings.settings.data;
        }
    }
    /**
     * Display error from Pug.
     *
     * @param error
     * @protected
     */
    _displayError(error) {
        puglint_stylish_1.default([error]);
    }
    /**
     * Method to add specific steps for the build.
     *
     * @param {NodeJS.ReadableStream} stream
     * @return {NodeJS.ReadableStream}
     * @protected
     */
    _hookBuildBefore(stream) {
        let data = [];
        // Load data from YAML files.
        if (typeof this._settings.settings.data === "string") {
            data = yaml.safeLoad(fs_1.default.readFileSync(this._settings.settings.data, "utf8"));
        }
        else if (typeof this._settings.settings.data === "object") {
            for (const filename of this._settings.settings.data) {
                data = merge_1.default(data, yaml.safeLoad(fs_1.default.readFileSync(filename, "utf8")));
            }
        }
        return stream.pipe(gulp_data_1.default(data)).pipe(gulp_pug_1.default());
    }
    /**
     * Method to add specific steps for the lint.
     *
     * @param {NodeJS.ReadWriteStream} stream
     * @param {TaskCallback} done
     * @return {NodeJS.ReadWriteStream}
     * @protected
     */
    _hookLint(stream, done) {
        const config = config_1.default.getInstance();
        return stream.pipe(gulp_pug_linter_1.default({
            reporter: (errors) => {
                if (errors.length > 0) {
                    this._lintError = true;
                    puglint_stylish_1.default(errors);
                    if (config.isLintRun()) {
                        for (const error of errors) {
                            task_extended_1.default.taskErrors.push({
                                taskName: this._taskName("lint"),
                                error,
                                done,
                            });
                        }
                    }
                }
            },
        }));
    }
}
exports.default = Pug;
/**
 * Global task name.
 * @type {string}
 * @readonly
 */
Pug.taskName = "pug";
/**
 * Level to order task in execution pipeline.
 * @type {number}
 * @readonly
 */
Pug.taskOrder = 50;
//# sourceMappingURL=pug.js.map