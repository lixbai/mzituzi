"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result["default"] = mod;
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
const fancy_log_1 = __importDefault(require("fancy-log"));
const gulp_1 = require("gulp");
const gulp_plumber_1 = __importDefault(require("gulp-plumber"));
const process_1 = __importDefault(require("process"));
const revision_1 = __importStar(require("../gulp-plugins/revision"));
const size_1 = __importDefault(require("../gulp-plugins/size"));
const config_1 = __importDefault(require("../libs/config"));
const task_1 = __importDefault(require("./task"));
/**
 * Task class to define complex Gulp tasks with lint, build and watch sub-tasks.
 */
class TaskExtended extends task_1.default {
    /**
     * Task constructor.
     *
     * @param {Options} options
     */
    constructor(options) {
        super(options);
        /**
         * Flag to init sizes anyway.
         * @type {boolean}
         * @protected
         */
        this._activeInitSizesAnyway = true;
        /**
         * Flag to display sizes or not.
         * @type {boolean}
         * @protected
         */
        this._activeSizes = true;
        /**
         * Browsersync settings.
         * @type {{}}
         * @protected
         */
        this._browserSyncSettings = {};
        /**
         * Flag to define if task could build sourcemaps.
         * @type {boolean}
         * @protected
         */
        this._gulpSourcemaps = false;
        /**
         * Force to hide gzipped size.
         * @type {boolean}
         * @protected
         */
        this._hideGzippedSize = true;
        /**
         * Flag to define if there is a lint error or not to block build.
         * @type {boolean}
         * @protected
         */
        this._lintError = false;
        /**
         * Suffix of the minified file.
         * @type {string}
         * @protected
         */
        this._minifySuffix = "";
        /**
         * List of files to watch in addition to the working files.
         * @type {string[]}
         * @protected
         */
        this._watchingFiles = [];
        this._browserSync = options.browsersync;
    }
    /**
     * Check if current task have linter.
     *
     * @returns {boolean}
     * @protected
     */
    get _haveLinter() {
        const config = config_1.default.getInstance();
        return !!this._hookLint && config.options.lint;
    }
    /**
     * Register build task in Gulp.
     *
     * @return {string}
     */
    taskBuild() {
        return this._defineTask("build", this._build.bind(this));
    }
    /**
     * Register lint task that run before build to check files validity.
     *
     * @return {string}
     */
    taskLint() {
        if (!this._haveLinter) {
            return "";
        }
        this._lintError = false;
        return this._defineTask("lint", this._lint.bind(this));
    }
    /**
     * Register watch task that watch change on files and run lint and build tasks.
     *
     * @return {string}
     */
    taskWatch() {
        return this._defineTask("watch", this._watch.bind(this));
    }
    /**
     * Display error.
     *
     * @param {unknown} error
     * @protected
     */
    _displayError(error) {
        fancy_log_1.default.error(error);
    }
    /**
     * Display error and exit if current task is a build task.
     *
     * @param {string} taskName
     * @param {unknown} error
     * @param {TaskCallback} done
     * @protected
     */
    _displayOrExitOnError(taskName, error, done) {
        const config = config_1.default.getInstance();
        this._displayError(error);
        TaskExtended.taskErrors.push({
            done,
            error,
            taskName,
        });
        if ((config.isLintRun() || config.isBuildRun()) && config.isCurrentRun(taskName)) {
            if (!!done)
                done();
            process_1.default.exit(1);
        }
    }
    /**
     * Build task.
     *
     * @param {TaskCallback} done
     * @returns {NodeJS.ReadableStream | void}
     * @protected
     */
    _build(done) {
        config_1.default.chdir(this._settings.cwd);
        const taskName = this._taskName("build");
        if (this._hookOverrideBuild) {
            return this._hookOverrideBuild(done);
        }
        // Start new stream with the files of the task.
        let stream = this._hookBuildSrc
            ? this._hookBuildSrc()
            : gulp_1.src(this._settings.src, {
                cwd: this._settings.cwd,
            });
        // Add plumber to avoid exit on error.
        stream = stream.pipe(gulp_plumber_1.default((error) => this._displayOrExitOnError(taskName, error, done)));
        // If there is no linter or no error, start specific logic of each task.
        if (!this._haveLinter || !this._lintError) {
            if (this._hookBuildBefore) {
                stream = this._hookBuildBefore(stream);
            }
            // Display file sizes.
            if ((this._activeSizes || this._activeInitSizesAnyway) && this._settings.sizes.normal) {
                const size = new size_1.default({
                    gzip: !this._hideGzippedSize && this._settings.sizes.gzipped,
                    minifySuffix: this._minifySuffix,
                    taskName,
                });
                stream = stream.pipe(size.log());
            }
            stream = stream.pipe(gulp_plumber_1.default.stop()).pipe(gulp_1.dest(this._settings.dst, { cwd: this._settings.cwd }));
            if (this._browserSync) {
                stream = stream.pipe(this._browserSync.sync(taskName, this._browserSyncSettings));
            }
            if (revision_1.isActive()) {
                stream = stream
                    .pipe(revision_1.default({
                    taskName,
                    cwd: this._settings.cwd,
                    dst: this._settings.revision,
                }))
                    .pipe(gulp_1.dest(".", { cwd: this._settings.cwd }));
            }
            if (this._bindEventsToBuilder) {
                this._bindEventsToBuilder(stream);
            }
        }
        return stream;
    }
    /**
     * Lint task.
     *
     * @param {TaskCallback} done
     * @returns {NodeJS.ReadableStream | void}
     * @protected
     */
    _lint(done) {
        config_1.default.chdir(this._settings.cwd);
        if (this._hookOverrideLint) {
            return this._hookOverrideLint(done);
        }
        let stream = this._hookLintSrc
            ? this._hookLintSrc()
            : gulp_1.src(this._settings.src, { cwd: this._settings.cwd });
        if (this._hookLint) {
            stream = this._hookLint(stream, done);
        }
        if (this._bindEventsToLinter) {
            this._bindEventsToLinter(stream);
        }
        return stream;
    }
    /**
     * Watch task.
     *
     * @param {TaskCallback} done
     * @protected
     */
    _watch(done) {
        const tasks = [];
        if (this._haveLinter) {
            tasks.push(this._taskName("lint"));
        }
        if (this._hookOverrideWatch) {
            this._hookOverrideWatch(done);
        }
        else {
            const srcWatch = [
                ...(typeof this._settings.src === "object" ? this._settings.src : [this._settings.src]),
                ...(this._settings.watch || []),
                ...this._watchingFiles,
            ];
            tasks.push(this._taskName("build"));
            const watcher = gulp_1.watch(srcWatch, { cwd: this._settings.cwd }, gulp_1.series(tasks));
            if (this._bindEventsToWatcher) {
                this._bindEventsToWatcher(watcher);
            }
        }
        if (done)
            done();
    }
}
exports.default = TaskExtended;
TaskExtended.runInParallel = true;
//# sourceMappingURL=task-extended.js.map