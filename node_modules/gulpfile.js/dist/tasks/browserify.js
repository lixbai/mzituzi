"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const async_1 = __importDefault(require("async"));
const browserify_1 = __importDefault(require("browserify"));
const chalk_1 = __importDefault(require("chalk"));
const fancy_log_1 = __importDefault(require("fancy-log"));
const gulp_1 = require("gulp");
const gulp_eslint_1 = __importDefault(require("gulp-eslint"));
const merge_1 = __importDefault(require("lodash/merge"));
const omit_1 = __importDefault(require("lodash/omit"));
const pretty_hrtime_1 = __importDefault(require("pretty-hrtime"));
const vinyl_buffer_1 = __importDefault(require("vinyl-buffer"));
const vinyl_source_stream_1 = __importDefault(require("vinyl-source-stream"));
const watchify_1 = __importDefault(require("watchify"));
const config_1 = __importDefault(require("../libs/config"));
const javascript_1 = __importDefault(require("./javascript"));
/**
 * Package Javascript using Browserify.
 */
class Browserify extends javascript_1.default {
    /**
     * Browserify constructor.
     *
     * @param {TaskOptions} options
     */
    constructor(options) {
        super(options);
        /**
         * List of files used by bundler.
         * @type {any[]}
         * @protected
         */
        this._bundleFiles = [];
        // Merge settings with default.
        const defaultSettings = {
            basedir: this._settings.cwd,
            debug: this._settings.sourcemaps,
            entries: this._settings.src,
        };
        this._settings.settings = merge_1.default(defaultSettings, this._settings.settings, watchify_1.default.args);
    }
    /**
     * Get bundler with transforms and plugins.
     *
     * @returns {browserify.BrowserifyObject}
     * @protected
     */
    get bundler() {
        const config = config_1.default.getInstance();
        // Initialize Browserify bundler.
        if (!this._bundler) {
            this._bundler = this.bundlerOnly;
            if (this._settings.settings.babel !== false) {
                this._bundler.transform("babelify", this._settings.settings.babel);
            }
            if (!config.isBuildRun()) {
                this._bundler.plugin("watchify");
            }
        }
        return this._bundler;
    }
    /**
     * Get bundler without transforms and plugins.
     *
     * @returns {browserify.BrowserifyObject}
     * @protected
     */
    get bundlerOnly() {
        // Initialize Browserify bundler only.
        if (!this._bundlerOnly) {
            const browserifyOptions = omit_1.default(this._settings.settings, ["babel", "eslint"]);
            this._bundlerOnly = browserify_1.default(browserifyOptions);
        }
        return this._bundlerOnly;
    }
    /**
     * Collect files used by bundler.
     *
     * @param {string} absolute
     * @param {string} relative
     * @protected
     */
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    _collectFilesForLint(absolute, relative) {
        if (this._bundleFiles.indexOf(absolute) < 0)
            this._bundleFiles.push(absolute);
    }
    /**
     * Pass files to ESLint.
     *
     * @param {string[]} files
     * @param {TaskCallback} done
     * @returns {NodeJS.ReadableStream}
     * @protected
     */
    _esLint(files, done) {
        return gulp_1.src(files, { allowEmpty: true, cwd: this._settings.cwd })
            .pipe(gulp_eslint_1.default(this._settings.settings.eslint))
            .pipe(gulp_eslint_1.default.format())
            .pipe(gulp_eslint_1.default.results((filesWithErrors) => {
            this._esLintResults(filesWithErrors, done);
        }))
            .on("finish", () => {
            if (done)
                done();
        });
    }
    /**
     * Fake Gulp logging used to provide unified feedback with watchify.
     *
     * @param {string} taskName
     * @param {Undertaker.TaskFunction} task
     * @param {TaskCallback} done
     * @protected
     */
    _fakeGulpTask(taskName, task, done) {
        const coloredTaskName = chalk_1.default.cyan(taskName);
        const start = process.hrtime();
        fancy_log_1.default(`Starting '${coloredTaskName}'...`);
        const callback = (done) => {
            return () => {
                const duration = process.hrtime(start);
                fancy_log_1.default(`Finished '${coloredTaskName}' after ` + chalk_1.default.magenta(pretty_hrtime_1.default(duration)));
                done();
            };
        };
        task(callback(done));
    }
    /**
     * Method to add specific steps for the build.
     *
     * @param {NodeJS.ReadableStream} stream
     * @return {NodeJS.ReadableStream}
     * @protected
     */
    _hookBuildBefore(stream) {
        stream = stream.pipe(vinyl_source_stream_1.default(this._settings.filename)).pipe(vinyl_buffer_1.default());
        stream = this._sourceMapsAndMinification(stream);
        return stream;
    }
    /**
     * Method to change default source for build task.
     *
     * @returns {NodeJS.ReadableStream}
     * @protected
     */
    _hookBuildSrc() {
        const self = this;
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        return this.bundler.bundle().on("error", function (err) {
            self._displayError(err);
            this.emit("end");
        });
    }
    /**
     * Method to override lint task.
     *
     * @param {TaskCallback} done
     * @returns {NodeJS.ReadableStream | void}
     * @protected
     */
    _hookOverrideLint(done) {
        if (this._settings.watch) {
            this._esLint(this._settings.watch, done);
            return;
        }
        async_1.default.series({
            "collect-files": (cb) => {
                this.bundlerOnly.on("file", this._collectFilesForLint.bind(this)).bundle(cb);
            },
        }, () => {
            this._esLint(this._bundleFiles, done);
        });
    }
    /**
     * Method to override watch task.
     *
     * @param {TaskCallback} done
     * @returns {NodeJS.ReadableStream | void}
     * @protected
     */
    _hookOverrideWatch(done) {
        this.bundler.on("update", () => {
            async_1.default.series({
                "0-lint": (cb) => {
                    const task = (cbt) => {
                        this._lint(cbt);
                    };
                    this._fakeGulpTask(this._taskName("lint"), task, cb);
                },
                "1-build": (cb) => {
                    if (this._haveLinter && this._lintError) {
                        return cb();
                    }
                    const task = (cbt) => {
                        const stream = this._build();
                        if (stream) {
                            stream.on("end", cbt);
                        }
                        else {
                            cbt();
                        }
                    };
                    this._fakeGulpTask(this._taskName("build"), task, cb);
                },
            }, () => {
                done();
            });
        });
    }
}
exports.default = Browserify;
/**
 * Global task name.
 * @type {string}
 * @readonly
 */
Browserify.taskName = "browserify";
/**
 * Level to order task in execution pipeline.
 * @type {number}
 * @readonly
 */
Browserify.taskOrder = 40;
//# sourceMappingURL=browserify.js.map