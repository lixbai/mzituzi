"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const chalk_1 = __importDefault(require("chalk"));
const del_1 = __importDefault(require("del"));
const fancy_log_1 = __importDefault(require("fancy-log"));
const gulp_filter_1 = __importDefault(require("gulp-filter"));
const gulp_imagemin_1 = __importDefault(require("gulp-imagemin"));
const gulp_newer_1 = __importDefault(require("gulp-newer"));
const gulp_rename_1 = __importDefault(require("gulp-rename"));
const imagemin_webp_1 = __importDefault(require("imagemin-webp"));
const merge_1 = __importDefault(require("lodash/merge"));
const merge_stream_1 = __importDefault(require("merge-stream"));
const minimatch_1 = __importDefault(require("minimatch"));
const path_1 = __importDefault(require("path"));
const task_extended_1 = __importDefault(require("./task-extended"));
/**
 * Minify images.
 */
class Images extends task_extended_1.default {
    /**
     * Task constructor.
     *
     * @param {TaskOptions} options
     */
    constructor(options) {
        super(options);
        /**
         * List of supported extension for WebP conversion.
         * @type {string[]}
         * @private
         * @readonly
         */
        this._webPSupportedExtension = ["**/*.jpg", "**/*.jpeg", "**/*.png"];
        const defaultSettings = {
            gifsicle: {
                interlaced: true,
                optimizationLevel: 3,
            },
            mozjpeg: {
                progressive: true,
            },
            optipng: {
                optimizationLevel: 5,
            },
            svgo: {
                plugins: [{ removeViewBox: true }, { cleanupIDs: false }],
            },
        };
        this._settings.settings = merge_1.default(defaultSettings, this._settings.settings || {});
        const webpDefaultSettings = {};
        if (typeof this._settings.settings.webp === "object") {
            this._settings.settings.webp = merge_1.default(webpDefaultSettings, this._settings.settings.webp);
        }
        else {
            this._settings.settings.webp = !!this._settings.settings.webp ? webpDefaultSettings : false;
        }
    }
    /**
     * Bind events to file watcher.
     * Delete destination file when a file was deleted in source.
     *
     * @param {fs.FSWatcher} watcher
     * @protected
     */
    _bindEventsToWatcher(watcher) {
        // Watch if files were deleted to delete in destination directory.
        watcher.on("unlink", (filename) => {
            const srcFilename = path_1.default.resolve(this._settings.cwd, filename);
            const srcParts = srcFilename.split("/");
            const dstFilename = path_1.default.resolve(this._settings.cwd, this._settings.dst);
            const dstParts = dstFilename.split("/");
            let newFilename = "/";
            let index = 0;
            while (srcParts[index] === dstParts[index] && (index < srcParts.length || index < dstParts.length)) {
                newFilename = path_1.default.join(newFilename, srcParts[index]);
                index++;
            }
            for (let i = index; i < dstParts.length; i++) {
                newFilename = path_1.default.join(newFilename, dstParts[i]);
            }
            newFilename = path_1.default.join(newFilename, path_1.default.basename(filename));
            this._deleteFile(newFilename);
            if (this._settings.settings.webp && this._webPSupportedFile(newFilename)) {
                this._deleteFile(newFilename + ".webp");
            }
        });
    }
    /**
     * Method to add specific steps for the build.
     *
     * @param {NodeJS.ReadableStream} stream
     * @return {NodeJS.ReadableStream}
     * @protected
     */
    _hookBuildBefore(stream) {
        const streams = [];
        stream = stream.pipe(gulp_newer_1.default(path_1.default.resolve(this._settings.cwd, this._settings.dst)));
        const streamImageMin = stream.pipe(gulp_imagemin_1.default([
            gulp_imagemin_1.default.mozjpeg(this._settings.settings.mozjpeg || {}),
            gulp_imagemin_1.default.optipng(this._settings.settings.optipng || {}),
            gulp_imagemin_1.default.gifsicle(this._settings.settings.gifsicle || {}),
            gulp_imagemin_1.default.svgo(this._settings.settings.svgo || {}),
        ], { verbose: true }));
        streams.push(streamImageMin);
        if (this._settings.settings.webp) {
            const streamWebP = stream
                .pipe(gulp_filter_1.default(this._webPSupportedExtension))
                .pipe(gulp_imagemin_1.default([imagemin_webp_1.default(this._settings.settings.webp)]))
                .pipe(gulp_rename_1.default((pPath) => {
                pPath.extname += ".webp";
            }));
            streams.push(streamWebP);
        }
        return merge_stream_1.default(streams);
    }
    /**
     * Simply delete a file.
     *
     * @param {string} filename
     * @private
     */
    _deleteFile(filename) {
        fancy_log_1.default("gulp-imagemin: Deleted image: " + chalk_1.default.blue(path_1.default.relative(this._settings.cwd, filename)));
        del_1.default.sync(filename, {
            force: true,
        });
    }
    /**
     * Check if a file is supported for WebP conversion.
     *
     * @param {string} filename
     * @return {boolean}
     * @private
     */
    _webPSupportedFile(filename) {
        return this._webPSupportedExtension.reduce((acc, ext) => acc || minimatch_1.default(filename, ext), false);
    }
}
exports.default = Images;
/**
 * Global task name.
 * @type {string}
 * @readonly
 */
Images.taskName = "images";
/**
 * Level to order task in execution pipeline.
 * @type {number}
 * @readonly
 */
Images.taskOrder = 30;
//# sourceMappingURL=images.js.map