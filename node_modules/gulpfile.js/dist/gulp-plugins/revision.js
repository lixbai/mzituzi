"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const crypto_1 = __importDefault(require("crypto"));
const fs_1 = __importDefault(require("fs"));
const isEmpty_1 = __importDefault(require("lodash/isEmpty"));
const merge_1 = __importDefault(require("lodash/merge"));
const path_1 = __importDefault(require("path"));
const plugin_error_1 = __importDefault(require("plugin-error"));
const through2_1 = __importDefault(require("through2"));
const vinyl_1 = __importDefault(require("vinyl"));
const vinyl_file_1 = __importDefault(require("vinyl-file"));
const config_1 = __importDefault(require("../libs/config"));
const utils_1 = require("../libs/utils");
var Hash;
(function (Hash) {
    Hash["MD5"] = "md5";
    Hash["SHA1"] = "sha1";
    Hash["SHA256"] = "sha256";
})(Hash || (Hash = {}));
/**
 * Collection of hashes.
 * @type {RevisionManifest}
 * @private
 */
let _manifest = {};
/**
 * Calculate the hash from a string or a Buffer.
 *
 * @param {string | Buffer} contents
 * @param {Hash} hash
 * @return {string}
 * @private
 */
function _hash(contents, hash) {
    if (typeof contents !== "string" && !Buffer.isBuffer(contents)) {
        throw new plugin_error_1.default("revision", "Expected a Buffer or string");
    }
    return crypto_1.default
        .createHash(hash)
        .update(contents)
        .digest("hex");
}
/**
 * Calculate the hash from a file with its name.
 *
 * @param {string} fileName
 * @param {Hash} hash
 * @return {string}
 * @private
 */
function _hashFile(fileName, hash) {
    return _hash(fs_1.default.readFileSync(fileName), hash);
}
/**
 * Push a new file in manifest and calculate the hash of this file.
 *
 * @param {HashData} data
 * @private
 */
function _pushHash(data) {
    const { type, name } = utils_1.explodeTaskName(data.taskName);
    let newData = {
        [type]: {
            [name]: {
                [data.origRelFile]: {
                    md5: _hash(data.contents, Hash.MD5),
                    revRelFile: data.revRelFile,
                    sha1: _hash(data.contents, Hash.SHA1),
                    sha256: _hash(data.contents, Hash.SHA256),
                },
            },
        },
    };
    if (!isEmpty_1.default(data.data)) {
        newData = merge_1.default(newData, {
            [type]: {
                [name]: {
                    [data.origRelFile]: {
                        data: data.data,
                    },
                },
            },
        });
    }
    // eslint-disable-next-line @typescript-eslint/no-use-before-define
    _manifest = _sortObjectByKeys(merge_1.default(_manifest, newData));
}
/**
 * Sort object by keys.
 *
 * @param {DefaultObject} object
 * @return {DefaultObject}
 * @private
 */
function _sortObjectByKeys(object) {
    const result = {};
    for (const key of Object.keys(object).sort()) {
        result[key] = typeof object[key] === "object" ? _sortObjectByKeys(object[key]) : object[key];
    }
    return result;
}
/**
 * Get hash for a file in a task.
 *
 * @param {string} taskName
 * @param {string} fileName
 * @param {Hash} hash
 * @return {string | boolean}
 */
function getHash(taskName, fileName, hash = Hash.SHA1) {
    const { type, name } = utils_1.explodeTaskName(taskName);
    // If revision is deactivated, return false.
    // eslint-disable-next-line @typescript-eslint/no-use-before-define
    if (!isActive()) {
        return false;
    }
    if (path_1.default.isAbsolute(fileName)) {
        return _hashFile(fileName, hash);
    }
    // Try to search and return hash.
    try {
        return _manifest[type][name][fileName][hash];
    }
    catch (e) {
        // Do nothing!
    }
    return false;
}
exports.getHash = getHash;
/**
 * Get hash for a file in a task to use in URL parameters (only the first 10 characters).
 *
 * @param {string} taskName
 * @param {string} fileName
 * @param {Hash} hash
 * @return {string | boolean}
 */
function getHashRevision(taskName, fileName, hash = Hash.SHA1) {
    const hashStr = getHash(taskName, fileName, hash);
    return hashStr === false ? hashStr : hashStr.slice(0, 10);
}
exports.getHashRevision = getHashRevision;
/**
 * Check if revision is activated.
 *
 * @return {boolean}
 */
function isActive() {
    const config = config_1.default.getInstance();
    return !!config.options.revision;
}
exports.isActive = isActive;
/**
 * Push arbitrary file in manifest.
 *
 * @param {string} fileName
 * @param {Options} options
 */
function pushAndWrite(fileName, options) {
    if (!isActive() || !path_1.default.isAbsolute(fileName)) {
        return;
    }
    // Get relative path and name of the file.
    const revPath = fileName.replace(/\\/g, "/");
    const revBase = path_1.default.dirname(fileName).replace(/\\/g, "/");
    // Get relative path between file and revision file.
    const origRelFile = path_1.default
        .join(path_1.default.relative(options.cwd, revBase), path_1.default.basename(revPath))
        .replace(/\\/g, "/");
    const revRelFile = path_1.default
        .relative(path_1.default.dirname(path_1.default.join(options.cwd, options.dst)), revPath)
        .replace(/\\/g, "/");
    fs_1.default.readFile(fileName, (error, data) => {
        if (error) {
            throw error;
        }
        _pushHash({
            taskName: options.taskName,
            origRelFile,
            revRelFile,
            contents: data,
        });
        fs_1.default.writeFile(path_1.default.resolve(options.cwd, options.dst), JSON.stringify(_manifest, null, "  "), "utf-8", (err) => {
            if (err) {
                throw err;
            }
        });
    });
}
exports.pushAndWrite = pushAndWrite;
/**
 * Collect hashes from build files.
 *
 * @param {Options} options
 * @return {Transform}
 */
exports.default = (options) => {
    const defaultOptions = {
        dst: "rev-manifest.json",
    };
    options = merge_1.default(defaultOptions, options);
    // Do nothing if revision is deactivated.
    if (!isActive()) {
        return through2_1.default.obj();
    }
    return through2_1.default.obj((file, encoding, cb) => {
        // Collect files and calculate hash from the stream.
        if (file.isNull()) {
            return cb();
        }
        if (file.isStream()) {
            return cb(new plugin_error_1.default("revision", "Stream not supported"));
        }
        // Exclude MAP files.
        if (path_1.default.extname(file.path) === ".map") {
            return cb();
        }
        // Get relative path and name of the file.
        const revBase = path_1.default.resolve(file.cwd, file.base).replace(/\\/g, "/");
        const revPath = path_1.default.resolve(file.cwd, file.path).replace(/\\/g, "/");
        // Get relative path between file and revision file.
        const origRelFile = path_1.default
            .join(path_1.default.relative(file.cwd, revBase), path_1.default.basename(revPath))
            .replace(/\\/g, "/");
        const revRelFile = path_1.default
            .relative(path_1.default.dirname(path_1.default.join(options.cwd, options.dst)), revPath)
            .replace(/\\/g, "/");
        // Insert file and calculated hashes into the manifest.
        _pushHash({
            taskName: options.taskName,
            origRelFile,
            revRelFile,
            contents: file.contents ? file.contents.toString() : "",
            data: file.revisionData || {},
        });
        cb();
    }, function (cb) {
        // Merge and write manifest.
        const manifestFile = options.dst;
        // Read manifest file.
        vinyl_file_1.default
            .read(manifestFile, options)
            .catch(
        // File not exists, create new one.
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        (error) => {
            if (error.code === "ENOENT") {
                return new vinyl_1.default({
                    path: manifestFile,
                });
            }
            throw error;
        })
            .then((manifest) => {
            let oldManifest = {};
            // Read manifest file.
            try {
                if (manifest.contents !== null) {
                    oldManifest = JSON.parse(manifest.contents.toString());
                }
            }
            catch (e) {
                // Do nothing!
            }
            // Merge memory and file. Sort it by keys to improve reading and file versioning.
            _manifest = _sortObjectByKeys(merge_1.default(oldManifest, _manifest));
            // Send manifest in stream.
            manifest.contents = Buffer.from(JSON.stringify(_manifest, null, "  "));
            this.push(manifest);
            cb();
        })
            .catch(cb);
    });
};
//# sourceMappingURL=revision.js.map