"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const chalk_1 = __importDefault(require("chalk"));
const cli_table_1 = __importDefault(require("cli-table"));
const events_1 = require("events");
const fancy_log_1 = __importDefault(require("fancy-log"));
const gzip_size_1 = __importDefault(require("gzip-size"));
const filter_1 = __importDefault(require("lodash/filter"));
const mapValues_1 = __importDefault(require("lodash/mapValues"));
const merge_1 = __importDefault(require("lodash/merge"));
const reduce_1 = __importDefault(require("lodash/reduce"));
const path_1 = __importDefault(require("path"));
const plugin_error_1 = __importDefault(require("plugin-error"));
const pretty_bytes_1 = __importDefault(require("pretty-bytes"));
const stream_counter_1 = __importDefault(require("stream-counter"));
const through2_1 = __importDefault(require("through2"));
/**
 * Collect sizes of build files and display it.
 */
class Size {
    /**
     * Calculate and display sizes of files in stream.
     *
     * @param {Options} options
     */
    constructor(options) {
        /**
         * Options.
         * @type {Options}
         * @private
         */
        this._options = {
            gzip: true,
            minifySuffix: "",
            taskName: "",
        };
        /**
         * List of generated files.
         * @type {FileSizes}
         * @private
         */
        this._files = {};
        /**
         * Check if all files are passed through the module.
         * @type {boolean}
         * @private
         */
        this._end = false;
        /**
         * Check if sizes are already displayed.
         * @type {boolean}
         * @private
         */
        this._displayed = false;
        this._options = merge_1.default(this._options, options);
        // Event emitter to know when all sizes are calculated.
        this._emitter = new events_1.EventEmitter();
        this._emitter.on("sizes-calculated", () => this._display());
        this._emitter.on("sizes-end", () => {
            this._end = true;
            this._display();
        });
    }
    /**
     * Format sizes in human readable form.
     *
     * @param {Sizes} sizes
     * @return {PrettySizes}
     * @private
     */
    static _prettyBytes(sizes) {
        return mapValues_1.default(sizes, (size) => pretty_bytes_1.default(size));
    }
    /**
     * Log sizes of files in a stream.
     *
     * @return {Transform}
     */
    log() {
        this._files = {};
        this._end = false;
        this._displayed = false;
        return through2_1.default.obj((file, encoding, cb) => {
            if (file.isNull()) {
                cb(null, file);
                return;
            }
            // Exclude MAP files.
            if (path_1.default.extname(file.path) === ".map") {
                return cb(null, file);
            }
            // Get relative filename regardless of its suffix.
            const relFilename = file.relative.replace(`${this._options.minifySuffix}${file.extname}`, file.extname);
            // Initialize sizes aggregator.
            if (typeof this._files[relFilename] === "undefined") {
                this._files[relFilename] = {
                    calculated: false,
                    sizes: {
                        minified: -1,
                        minifiedGzipped: -1,
                        size: -1,
                        sizeGzipped: -1,
                    },
                };
            }
            // Collect sizes.
            const finish = (error, size, keys) => {
                if (error) {
                    cb(new plugin_error_1.default("size", error));
                    return;
                }
                // Collect size.
                const keySize = this._options.minifySuffix !== "" && file.relative.indexOf(this._options.minifySuffix) >= 0
                    ? keys[1]
                    : keys[0];
                this._files[relFilename].sizes = merge_1.default(this._files[relFilename].sizes, {
                    [keySize]: size,
                });
                // Count calculated sizes.
                const countSizes = filter_1.default(this._files[relFilename].sizes, (size) => size >= 0)
                    .length;
                // Determine if all sizes is here.
                const calculated = this._files[relFilename].calculated;
                this._files[relFilename].calculated =
                    (this._options.minifySuffix === "" && !this._options.gzip && countSizes === 1) ||
                        (this._options.minifySuffix !== "" && !this._options.gzip && countSizes === 2) ||
                        (this._options.minifySuffix === "" && this._options.gzip && countSizes === 2) ||
                        (this._options.minifySuffix !== "" && this._options.gzip && countSizes === 4);
                // Emit event if all sizes are calculated.
                if (!calculated && this._files[relFilename].calculated) {
                    this._emitter.emit("sizes-calculated", { relFilename });
                }
            };
            // Collect gzipped sizes.
            const finishGzip = (error, size) => {
                finish(error, size, ["sizeGzipped", "minifiedGzipped"]);
            };
            // Collect normal sizes.
            const finishSize = (error, size) => {
                finish(error, size, ["size", "minified"]);
            };
            if (file.isStream()) {
                // Get file size from a stream.
                file.contents
                    .pipe(new stream_counter_1.default())
                    .on("error", finishSize)
                    // eslint-disable-next-line @typescript-eslint/no-explicit-any
                    .on("finish", function () {
                    finishSize(null, this.bytes);
                });
                // Get gzipped file size from a stream.
                if (this._options.gzip) {
                    file.contents
                        .pipe(gzip_size_1.default.stream())
                        .on("error", finishGzip)
                        // eslint-disable-next-line @typescript-eslint/no-explicit-any
                        .on("end", function () {
                        finishGzip(null, this.gzipSize);
                    });
                }
            }
            else if (file.isBuffer()) {
                // Get file size.
                finishSize(null, file.contents ? file.contents.length : 0);
                // Get gzipped file size.
                if (this._options.gzip) {
                    gzip_size_1.default(file.contents).then((size) => {
                        finishGzip(null, size);
                    });
                }
            }
            cb(null, file);
        }, (cb) => {
            this._emitter.emit("sizes-end");
            cb();
        });
    }
    /**
     * Display collected sizes.
     *
     * @private
     */
    _display() {
        const calculatedCount = reduce_1.default(this._files, (count, file) => count + (file.calculated ? 1 : 0), 0);
        const filesCount = Object.keys(this._files).length;
        if (!this._end || this._displayed || filesCount === 0) {
            return;
        }
        // Head of the table.
        const head = ["Filename".padEnd(35, " "), "Size".padStart(8, " ")];
        if (this._options.minifySuffix !== "") {
            head.push("Minified", "Saved".padStart(16, " "));
        }
        // If all sizes are calculated, display them.
        if (calculatedCount >= filesCount) {
            this._displayed = true;
            // Collect sizes in a simple array.
            const files = Object.keys(this._files)
                .sort()
                .map((filename) => {
                const file = this._files[filename];
                const prettySizes = Size._prettyBytes(file.sizes);
                const row = [
                    chalk_1.default.cyan(filename),
                    prettySizes.size + (this._options.gzip ? chalk_1.default.gray(`\n${prettySizes.sizeGzipped} gzipped`) : ""),
                ];
                // Add minified information and differential value.
                if (this._options.minifySuffix !== "") {
                    const saved = Math.max(0, file.sizes.size - file.sizes.minified);
                    const savedPercent = file.sizes.size === 0 ? 0 : (saved * 100) / file.sizes.size;
                    const formatPercent = savedPercent.toFixed(1).padStart(4, " ");
                    row.push(prettySizes.minified + (this._options.gzip ? chalk_1.default.gray(`\n${prettySizes.minifiedGzipped} gzipped`) : ""), `${pretty_bytes_1.default(saved)} ${chalk_1.default.gray(`(${formatPercent}%)`)}`);
                }
                return row;
            });
            // Create table to display.
            const table = new cli_table_1.default({
                colAligns: ["left", "right", "right", "right"],
                head: head.map((item) => chalk_1.default.blue(item)),
            });
            // Add values to display.
            table.push(...files);
            // Display sizes.
            fancy_log_1.default(`Sizes from '${chalk_1.default.cyan(this._options.taskName)}':\n` + table.toString());
        }
    }
}
exports.default = Size;
//# sourceMappingURL=size.js.map