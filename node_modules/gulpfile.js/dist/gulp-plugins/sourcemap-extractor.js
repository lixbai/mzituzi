"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const data_urls_1 = __importDefault(require("data-urls"));
const plugin_error_1 = __importDefault(require("plugin-error"));
const through2_1 = __importDefault(require("through2"));
const commentSearch = /(?:\/\/[@#][\s]*sourceMappingURL=([^\s'"]+)[\s]*$)|(?:\/\*[@#][\s]*sourceMappingURL=([^\s*'"]+)[\s]*(?:\*\/)[\s]*$)/gm;
/**
 * Extract inline sourcemap and integrate to file definition.
 *
 * @returns {Transform}
 */
exports.default = () => {
    return through2_1.default.obj(function (file, encoding, cb) {
        if (file.isNull()) {
            return cb(null, file);
        }
        if (file.isStream()) {
            return cb(new plugin_error_1.default("sourcemap-extractor", "Stream not supported"));
        }
        if (!file.contents) {
            return cb(null, file);
        }
        const contents = file.contents.toString();
        // Search last sourcemap.
        let match;
        let lastMatch = null;
        while ((match = commentSearch.exec(contents)))
            lastMatch = match;
        if (lastMatch === null) {
            return cb(null, file);
        }
        // Remove inline sourcemap.
        file.contents = Buffer.from(contents.replace(lastMatch[0], ""));
        // Integrate sourcemap to file.
        if (!file.sourceMap) {
            file.sourceMap = JSON.parse(data_urls_1.default(lastMatch[1]).body.toString());
            file.sourceMap.file = file.relative;
        }
        cb(null, file);
    });
};
//# sourceMappingURL=sourcemap-extractor.js.map